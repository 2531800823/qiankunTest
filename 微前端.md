# 微前端

> 微前端（Micro-Frontends）是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立运行、独立开发、独立部署。**微前端不是单纯的前端框架或者工具，而是一套架构体系**，这个概念最早在2016年底被提出。



### 微前端的价值

- 技术栈无关
  -  主框架不限制接入应用的技术栈，子应用具备完全自主权

- 独立开发、独立部署
  -  子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新

- 增量升级
  -  在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略

- 独立运行时
  - 每个子应用之间状态隔离，运行时状态不共享

### 微前端能解决我们什么问题

- 业务模块之间不断的堆叠，交错引用，业务耦合如何治理？
- 老技术、老代码不敢动，新技术、新架构又想用？
- 万年技术债？既要跟随业务敏捷迭代，又要保证代码库向好发展，旧的框架类库如何平稳升级？
- 一个项目多个团队开发，你冲突我，我冲突你，如何解决并行开发的冲突？
- 代码库持续膨胀，难以维护的项目代码，是屎上雕花？还是从头再来？



## qiankun 简介

> **qiankun不是一个完整的微前端解决方案！**
>
> 微前端并不是万能的”解药“，没有正确治理，所有的 codebase 的归宿都是”屎山”

qiankun 是一个生产可用的微前端框架，它基于 [single-spa](https://single-spa.js.org/) 开发，具备 js 沙箱、样式隔离、HTML Loader、预加载 等微前端系统所需的能力。qiankun 可以用于任意 js 框架，微应用接入像嵌入一个 iframe 系统一样简单。

`single-spa`是通过监听 url change 事件，在路由变化时匹配到渲染的子应用并进行渲染，这个思路也是目前实现微前端的主流方式。同时`single-spa`要求子应用修改渲染逻辑并暴露出三个方法：`bootstrap`、`mount`、`unmount`，分别对应初始化、渲染和卸载，这也导致子应用需要对入口文件进行修改。因为`qiankun`是基于`single-spa`进行封装，所以这些特点也被`qiankun`继承下来，并且需要对webpack配置进行一些修改。



![qiankun](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714da34745513b4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)





### 路由系统

劫持 url change 事件从而实现自己的路由系统，qiankun 这里，就直接选用了社区成熟的方案 single-spa。 single-spa 已经劫持的路由，做好了加载这件事情，也做好了路由切换这件事情。

### 应用接入：协议接入

使用了 single-spa，由于需要技术栈无关，所以我们希望接入是一个 **协议接入**。只要你的应用实现了 `bootstrap` 、`mount` 和 `unmount` 三个生命周期钩子，有这三个函数导出，我们的框架应用就可以知道如何加载这个子应用。

### 应用入口选择：HTML Entry

qiankun 的选择是 HTML 入口，就是提供一份 HTML 文件。因为这份 HTML 中其实包含了子应用的所有信息。比单纯你拿 JS 和 CSS 组成一份资源列表作为入口，要清晰和完整得多。**但是没有办法提取公共出来。**

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/7/17326a9aa5b5426e~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img" style="zoom: 50%;" />



### 应用隔离：JS沙箱

沙箱实现思路有两条：

1. 其中最经典的实践思路其实是**快照沙箱**。 -- 1.x 版本

   > 快照沙箱就是在应用沙箱挂载和卸载的时候记录快照，在应用切换的时候依据快照恢复环境。

   ​	实现思路：

   - 用 **windows diff**。把当前的环境和原来的环境做一个比较，我们跑两个循环，把两个环境作一次比较，然后去全量地恢复回原来的环境。、
   - **ES6 的 proxy **。通过劫持 window ，我们可以劫持到子应用对全局环境的一些修改。当子应用往 window 上挂东西、修改东西和删除东西的时候，我们可以把这个操作记录下来。当我们恢复回外面的全局环境的时候，我们只需要反向执行之前的操作即可。

2. 让子应用里面的环境和外面的环境完全隔离

​    如图所示，A 应用就活在 A 应用的沙箱里面，B 应用就活在 B 应用的沙箱里面，两者之间要不发生干扰，这个沙箱的实现思路其实也是通过 ES6 的 proxy，也通过代理特性实现的。

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/7/17326a9ab874b122~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img" style="zoom:33%;" />

### 样式隔离

#### Dynamic Stylesheet

当你从子应用 A 切换到子应用 B 的时候，这个时候需要把子应用的样式表 A 的样式给删除，把子应用 B 的样式表给挂载。但是和主应用的样式表有冲突

#### 工程化手段

- 使用 css module - 通过编译生成不冲突的选择器名
- css-in-js - 将 css 和 js 编码写在一起，然后生成不冲突的选择器

#### [Shadow DOM](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM)

Shadow DOM 是可以真正的做到 CSS 之间完全隔离的，在 Shadow Boundary 这个阴影边界阻隔之下，主应用的样式和子应用的样式可以完完全全的切分开来。但是他是有一个边界问题的，就比如 在 `document.body` 添加一个 `modal对话框`  他就跳出了 **Shadow Dom** 样式就会失效了。



### 应用通讯

#### 基于 URL

在路由跳转的时候，传入一个 `query参数`通讯，缺点是：传递的信息有限

#### 发布/订阅

- 可以使用 window 的 [CustomEvent](https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent) 创建自定义事件，然后在任意地方派发这个自定义事件，就可以通过自定义事件来做到应用间的通讯。
- 使用 事件订阅发布的库

#### 基于 官网支持的 props 

```ts
registerMicroApps([
  {
    name: 'react app', // app name registered
    entry: '//localhost:7100',
    container: '#yourContainer',
    activeRule: '/yourActiveRule',
    props:{
        value:0
    }
  },
]);
```

#### 基于 官网 api GlobalState （不建议使用，在qiankun3.0会移除 ）

--

### qiankun 的发展和未来

[qiankun 3.0 路线](https://github.com/umijs/qiankun/discussions/1378)



> 事实上如果所有的 web 技术栈能做到统一，所有 library 的升级都能做到向下兼容，我们确实就不需要微前端了。  —— 鲁迅

> 鲁迅并没有说过这句话。 ------ 白岩松

> 白岩松并没有说过这句话。 ------马云

> 马云并没有说过这句话。 ------王健林





## 参考资料

- [可能是你见过最完善的微前端解决方案](https://zhuanlan.zhihu.com/p/78362028)

- [微前端的核心价值](https://zhuanlan.zhihu.com/p/95085796)



## 诉求

**如何确保遗产代码能平滑的迁移，以及如何确保我在若干年后还能用上热门的技术栈？**

我们只需要在主系统构造一个足够轻量的基座，然后让各子应用按照共同的协议去实现即可。这个协议可以包括，主应用应该如何加载子应用，以及子应用如何被主应用感知、调度，应用之间如何通信等。这个协议不应该包括，子应用要如何确保隔离性、安全性，也就是子应用除了实现一些较为简单的协议之外，跟开发一个正常的 spa 应用应该没有任何差别，包括不应该有 开发、构建、发布 等流程上的侵入。只要子应用实现了这几个协议，其他的东西怎么玩，我们都不需要关心或干预。

这样的话，其实整个系统就变成了一个真正的、基于运行时的插件平台了。

